\documentclass[book.tex]{subfiles}
\begin{document}
\section{Source Code}
The game engine was released on July 21, 1995. It is still there:\\ 
\\\codeword{ftp://ftp.idsoftware.com/idstuff/source/wolfsrc.zip}.\\
\\
\textbf{\underline{Trivia :}} Before the times of nmap and WireShark, ftp was commonly used to transfer files: It was simple and naively transmitted username and password in clear. Needless to say it did not age well...\\

\section{First Contact}
The file \codeword{woldsrc.zip} contains an other self-extracting PKZIP archive. It was a convenience back in the day but it is not practical nowadays. You can deflate it with:\\
\\\codeword{unzip WOLFSRC.1}.\\
\\The source code actually contains more than just \codeword{.H} (headers) and \codeword{.C} (code) files. Also present are:
\begin{itemize}
\item \codeword{.EQU}
\item \codeword{\_WL1.H}
\item \codeword{\_WL6.H}
\item \codeword{\_SOD.H}
\item \codeword{\_SDM.H}
\item \codeword{GOODSTUF.TXT} A letter from a POW playing Wolfenstein 3D.
\item \codeword{.ASM} Assembly optimized routines. Also contains  routines to access VGA and refresh screen.
\item \codeword{SIGNON.OBJ/}: The startup screen showing the system characteristic (RAM, EMS, XMS, Joystick, SoundCards) was linked in the binary. Because that screen was showed before any sub-system was started. TODO: This should be a trivia.
\item \codeword{GAMEPAL.OBJ/} Game palette. Hardcoded and linked in the executable for the same reason described previously.
\item \codeword{README/} How to build. You can find a complete tutorial in the Annexe of this book.
\item \codeword{RULES.ASI} ???
\item \codeword{SV.EXE} ???
\item Many files resulting in a previous compilation attempt.
\end{itemize}
A quick stats:\\
\begin{verbatim}
wolfsrc\$ cloc-1.64.pl .

      96 text files.
      94 unique files.                              
      27 files ignored.

--------------------------------------------------------------------------
Language                files          blank        comment           code
--------------------------------------------------------------------------
C++                        26           5750           6201          21169
C/C++ Header               42            802            660           3900
Assembly                   10            669            732           2150
DOS Batch                   1              1              0              4
--------------------------------------------------------------------------
SUM:                       79           7222           7593          27223
--------------------------------------------------------------------------
\end{verbatim}
The game engine is mostly C with a few ASM routines for optimized stuff and I/O.\\


 \begin{fancyquotes}
   We didn't have spell checkers in our editors back then, and I always had poor spelling.  The word "collumn" appears in the source code dozens of times.  After I released the source code, one of the emails that stands out in memory read:
 \bigskip \\
It's "COLUMN", you dumb @\#\$\% !\\
 \bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}

\begin{fancyquotes}
Estimated completion time ?  
\textbf{John Carmack - Programmer}
 \end{fancyquotes}
 
\section{Architecture}

The engine is made of sub-systems called Managers:
\begin{itemize}
	\item Memory
	\item Page
	\item Video
	\item Cache
	\item Sound
	\item User
	\item Input
\end{itemize}
Together they harness the machine to play sound, music and display the two phases of the game:
\begin{itemize}
	\item 2D Menus
	\item 3D Action
\end{itemize}


\begin{figure}[H]
\centering
\includegraphics[scale=0.9]{imgs/architecture.eps}
\caption{Architecture and sub-systems.}
\label{fig:architecture}
\end{figure}

\begin{figure}[H]
  \centering
 \includegraphics[scale=1.3]{imgs/palette.png}
 \caption{The 3D sequence palette.} \label{fig:palette}
\end{figure}


\begin{figure}[H]
  \centering
 \includegraphics[scale=1.3]{imgs/palette_damage.png}
 \caption{The palette RGB colors altered when taking damage.} \label{fig:palette_damage}
\end{figure}



\begin{figure}[H]
  \centering
 \includegraphics[scale=1.3]{imgs/ray_caster_explained/beginning.png}
 \caption{Raycasting 1: Screenshot} \label{fig:Raycasting2Drawing}
\end{figure}

\begin{figure}[H]
  \centering
  \input{imgs/ray_caster_explained/beginning.tex}
 \caption{Raycasting 1: Drawing} \label{fig:Raycasting1}
\end{figure}




\begin{figure}[H]
  \centering
 \includegraphics[scale=1.3]{imgs/ray_caster_explained/out_door.png}
 \caption{Raycasting 2: Screenshot} \label{fig:Raycasting2Drawing}
\end{figure}

\begin{figure}[H]
\centering
 \input{imgs/ray_caster_explained/out_room.tex}
 \caption{The 320 rays cast to render the walls in the previous scene.} \label{fig:Raycasting2}
\end{figure}
 
 

\section{Unrolled Loop}

\subsection{Memory Manager (MM)}

\subsection{Page Manager (PM)}

The Page Manager harness the three types of RAM available: Conventional, XMS and XML. It abstract this complexity behind a Paging system.\\
Is it where the loading screen shows a progress bar ?
"Get Psyched !!!": Fill up the cache ?
Trivia: The progress bar was called a "thermometer".
The Page Manager provides all asset during 3D rendition. 
It loads as many "Pages" as possible in Main, XMS and EMS memory during the get Psyched screen.
TODO: Add a screenshot.
It uses a Least Frequency Used eviction policy if not all asset fit in RAM. VSWAP.WL6 is 1.6MB -> Recommended configuration 2MB RAM..but the game would run with just 640KB.
\subsection{Video Manager (VW)}


\subsection{Cache Manager (CA)}
The Cache Manager takes care of all the assets during Menu Phases: Sprites, Music, Sounds.
\subsection{Sound Manager (SD)}
The Sound Manager abstract interaction with all four sound systems supported: PC Speaker, ADLib (Music only), Sound Blaster (Mono), Sound Blaster Pro (Stereo).
\subsection{User Manager (US)}


\subsection{Input Manager (IN)}
Abstract interaction with keyboard and mouse.

\section{Introduction Phase}
The game starts with the "resource summary" which display the available RAM, Inputs and Audio systems. Then it is followed by the title screen and the the disclaimer screen. Subversive spirit.

\section{Renderer: Mode X and Mode Y}
As seen in the Hardware chapter, none of the VGA modes offered could do what a game needed. But game developers found

a way: Mode X \footnote{X-Mode Frequently Asked Questions - By Zoombapup (Phil)  2-Oct-94}. Nobody knows who discovered mode-X but the person who popularized it is Michael Abrash \footnote{Michael Abrash's Graphic Programming Black Book: Chapter 47, page 877.}. The idea is to disable the "convenience" mechanism making the 4 banks appear as one. It is called putting the VGA in unchained mode where each bank of memory (called "plane") is written to individually.\\
With this technique the 64KB of mapped RAM can access the full 256KB of the VGA. This enables a mode offering:
\begin{itemize}
	\item Resolution of 320x200
	\item Double buffering
	\item Storage of sprites in VRAM.
\end{itemize}

Compared to figure 
TODO: New Drawing of VGA RAM.\\
But there is still a problem: Switching the target RAM was very slow. So a routine drawing an horizontal line on the screen:

\begin{verbatim}
void DrawLine(y, color) {
  for(int x=0; x < 320 ; x++) {
    SelectBrank(x % 4);
    WritePixel(x, y, color);   
  }
}
\end{verbatim}\\
Would have been unpractical. But something else can be done if you notice that 320 is a multiple of 4 (320/4=80): If you draw only columns you don't have to change the target plan often.\\
TOOD: Drawing of how column line up in VGA RAM.\\

\section{Menu Phase: 2D Renderer}
The menu phase is renderer by the 2D renderer which is tile based. The screen is divided into tiles as follow:\\
DRAWING\\
Bla bla bla\\

\section{Action Phase: 3D Renderer}

Raycasting DDA: "http://lodev.org/cgtutor/raycasting.html"

\subsection{Map}
Show map.\\
Show 64x64.\\
Show angle orientation.\\
\subsection{Fixed point}
\subsection{Raytracing: DDA Algorithm}
Digital Differential Analysis\\
Some ray are not traced ? How does that work ?\\
Precalculated sin-cos.\\
\subsection{FishEye}

\begin{figure}[H]
\centering
 \input{imgs/fish_eye/state.tex}
 \caption{blabla.} \label{fig:Raycasting2}
\end{figure}

\begin{figure}[H]
\centering
 \input{imgs/fish_eye/d_vs_z.tex}
 \caption{blabla.} \label{fig:Raycasting2}
\end{figure}

\begin{figure}[H]
\centering
 \input{imgs/fish_eye/correct_way.tex}
 \caption{blabla.} \label{fig:Raycasting2}
\end{figure}

\begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{imgs/fish_eye/bad_mild.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
 
\begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{imgs/fish_eye/bad_ok.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
 
 \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{imgs/fish_eye/bad_bad.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}

 \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{imgs/fish_eye/fish_eye.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
 
  \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{imgs/fish_eye/fish_eye_corrected.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
 
  \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{imgs/fish_eye/fish_eyed_start_screen2.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
\subsection{Door}
\subsection{Texturing}
Pre-Lighted texture.\\
Scaler (precompiled).\\

\subsection{Rendering phases}

Upon finishing parameter selection, the engine would switch from Menu phase to Action Phase which was mostly about rendering the 3D environment. The renderer operated in four phases:
\begin{itemize}
   \item Draw Background
   \item Draw Walls
   \item Draw scaled (entities such as enemies and items)
   \item Draw current weapon
\end{itemize}


Trivia: Hard-coded cos and sin lookup table. Budget ? 

\subsection{Square World and RayCasting}
TODO: Wolfenstein 3D referencial (64 grid, with origin and rotation
\subsection{Compiled Scalars}
Builds a compiled scaler object that will scale a 64 tall object to the given height (centered vertically on the screen).
\codeword{SetupScaling}\\
\codeword{BuildCompScale}
\lstinputlisting[language=C]{code/compscale.c}




\begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{screenshots/wolf3d_1_background.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
The floor was always the same color. The ceiling however changed see \codeword{WL\_DRAW.C} for a hard-coded index. TODO: Include a clear screen from a later level.\\
\begin{figure}[H]
 \centering
  \includegraphics[scale=1.3]{screenshots/wolf3d_4_partial_wall_32rays.png}
  \caption{3D Rendere Phase 2: Walls (160 rays)}
  \label{fig:mips}
\end{figure}
 
\begin{figure}[H]
 \centering
  \includegraphics[scale=1.3]{screenshots/wolf3d_5_partialwalls_160rays.png}
 \caption{Finalez frame} 
 \label{fig:mips}
\end{figure}
 
 
 \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{screenshots/wolf4d_2_walls.png}
 \caption{3D Rendere Phase 2: Walls completed} \label{fig:mips}
 \end{figure}
 
 
 \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{screenshots/wolf3d_6_scaled}
 \caption{3D Rendere Phase 3: Scaled} \label{fig:mips}
 \end{figure}

 \begin{figure}[H]
\centering
 \includegraphics[scale=1.3]{screenshots/wolf3d_7_fullframe.png}
 \caption{3D Rendere Phase 2: Weapon} \label{fig:mips}
 \end{figure}
 

   Synergy: VGA column drawing, raycasting, occlusion array

\section{I.A: Stage Machines}
 
If integers were not accurate enough and floating points were too slow, how could trigonometry be done on those machines? The solution was to re-purpose the hardware via Fixed Points!\\
Fixed Point is a method that allows to keep track of fractions while still using the integer operations of the CPU. The machine manipulates what are supposed to be integer numbers but the programmers sees them as a real numbers. As usual it is easier to describe with a drawing. Integer are encoded following figure \ref{fig:int_layout}:
\begin{figure}[H]
\centering
 \input{int.tex}
 \caption{Integer layout.} \label{fig:int_layout}
 \end{figure}

So the value of the sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
\centering
\input{int_example.tex}
 \caption{Integer example.} \label{fig:mips}
 \end{figure}

 Is equal to $ 2^{13} + 2^9 + 2^5 + 2^1 =  8738 $.

\bigskip


Fixed Point arithmetic works by simply shifting the layout 8 bits to the left:
\begin{figure}[H]
 \centering
  \input{fp.tex}
 \caption{Fixed point layout.} \label{fig:mips}
\end{figure}

So the same sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
 \centering
   \input{fp_example.tex}
  \caption{Fixed point example.} \label{fig:mips}
\end{figure} 

Now represents:\\
\\
$ 2^5 + 2^1 = 34 $ for the integer part.\\
$ 2^{-3}+2^{-7} = 0.1328125 $ for the fractional part.\\
$ = 34.1328125$\\

\bigskip

The beauty of this method is that addition and subtraction work exactly like integers from the CPU instruction side:
  \bigskip
  DRAWING
  \bigskip


 The only special case is when performing operation.

\bigskip
  DRAWING
  \bigskip



 \textbf{\underline{Trivia :}}  Fixed Point Arithmetic usage was not limited to PC gaming. Many game console manufactured in the 90s and later had no hardware floating point unit: Sony's original PlayStation (1994) and Sega's Saturn (1994) are few examples among many with a design choice that not only reduced the production cost but also maximized the CPU pipeline throughput.
 
 
 
\begin{fancyquotes}
Much was made about the "ray casting" used in Wolfenstein, but the real reason for it was that I had a lot of trouble with wall-span rendering in Catacombs 3D.  C3D (and Hovertank before that) shipped with various graphics glitches that you could get in some combinations of map block configurations, position, and viewing angle.  Some were due to fixed point precision issues not being handled optimally, and some were due to clipping and culling issues that I didn’t really get a handle on until a couple years later.  In any case, they bothered me a lot.  Spurious graphics glitches do a lot of harm to the sense of immersion in a game, and I very much wanted Id games to feel “rock solid”.
 \bigskip \\
There was a clear performance cost to it – doing 320 traces through a tile map and treating each column independently is much slower than looping through a few long wall segments.  However, the resulting code was small and very regular compared to the hairball of my wall span renderers, and it did deliver the rock-solid feel I wanted.
 \bigskip \\
If you made extremely jagged block maps that would turn into many dozen independent wall segments, the ray casting could start to look like a good performance choice, but few scenes were even close to that.  This is exactly the same ray tracing versus rasterization performance tradeoff that is still being made today, but now it is “how many tens of millions of triangles per frame to ray tracing break-even” instead of “how many dozen wall segments”.
 \bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}
 

\end{document}

