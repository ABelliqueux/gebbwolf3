\documentclass[book.tex]{subfiles}
\begin{document}
\section{Source Code}

Includel list of all files.\\
Include cloc stats.

 \begin{fancyquotes}
   We didn't have spell checkers in our editors back then, and I always had poor spelling.  The word “collumn” appears in the source code dozens of times.  After I released the source code, one of the emails that stands out in memory read:
 \bigskip \\
It's "COLUMN", you dumb @\#\$\% !\\
 \bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}


\section{Unrolled Loop}
\section{Architecture}
\subsection{Memory Manager (MM)}
\subsection{Page Manager (PM)}
\subsection{Video Manager (VW)}
\subsection{Cache Manager (CA)}
\subsection{Sound Manager (SD)}
\subsection{User Manager (US)}
\subsection{Input Manager (IN)}


\section{2D Renderer}

\section{3D Renderer}
\section{Fixed Point}
If integers were not accurate enough and floating points were too slow, how could trigonometry be done on those machines? The solution was to re-purpose the hardware via Fixed Points!\\
\begin{figure}[H]
\centering
 \includegraphics[scale=0.8]{imgs/wolfd_0.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}


\begin{figure}[H]
\centering
 \includegraphics[scale=1.1]{imgs/wolfd_1.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}

 
     \begin{figure}[H]
\centering
 \includegraphics{imgs/wolfd_2_1.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}
 
 \begin{figure}[H]
\centering
 \includegraphics{imgs/wolfd_2_2.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}
 
 \begin{figure}[H]
\centering
 \includegraphics{imgs/wolfd_2_3.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}

 \begin{figure}[H]
\centering
 \includegraphics{imgs/wolfd_2_5.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}
 
  \begin{figure}[H]
\centering
 \includegraphics[scale=1]{imgs/wolfd_3.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}
 
   \begin{figure}[H]
\centering
 \includegraphics[scale=0.8]{imgs/wolf3d_4.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}
 
   \begin{figure}[H]
\centering
 \includegraphics[scale=1]{imgs/wolfd_4-2.eps}
 \caption{Finalez frame} \label{fig:mips}
 \end{figure}
   \bigskip
   
   
   

 

Fixed Point is a method that allows to keep track of fractions while still using the integer operations of the CPU. The machine manipulates what are supposed to be integer numbers but the programmers sees them as a real numbers. As usual it is easier to describe with a drawing. Integer are encoded following figure \ref{fig:int_layout}:
\begin{figure}[H]
\centering
 \input{int.tex}
 \caption{Integer layout.} \label{fig:int_layout}
 \end{figure}

So the value of the sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
\centering
\input{int_example.tex}
 \caption{Integer example.} \label{fig:mips}
 \end{figure}

 Is equal to $ 2^{13} + 2^9 + 2^5 + 2^1 =  8738 $.

\bigskip

Fixed Point arithmetic works by simply shifting the layout 8 bits to the left:
\begin{figure}[H]
 \centering
  \input{fp.tex}
 \caption{Fixed point layout.} \label{fig:mips}
\end{figure}

So the same sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
 \centering
   \input{fp_example.tex}
  \caption{Fixed point example.} \label{fig:mips}
\end{figure} 

Now represents:\\
\\
$ 2^5 + 2^1 = 34 $ for the integer part.\\
$ 2^{-3}+2^{-7} = 0.1328125 $ for the fractional part.\\
$ = 34.1328125$\\

\bigskip

The beauty of this method is that addition and subtraction work exactly like integers from the CPU instruction side:
  \bigskip
  DRAWING
  \bigskip


 The only special case is when performing operation.

\bigskip
  DRAWING
  \bigskip

 \textbf{\underline{Trivia :}}  Fixed Point Arithmetic usage was not limited to PC gaming. Many game console manufactured in the 90s and later had no hardware floating point unit: Sony's original PlayStation (1994) and Sega's Saturn (1994) are few examples among many with a design choice that not only reduced the production cost but also maximized the CPU pipeline throughput.
 
 
 
\begin{fancyquotes}
Much was made about the "ray casting" used in Wolfenstein, but the real reason for it was that I had a lot of trouble with wall-span rendering in Catacombs 3D.  C3D (and Hovertank before that) shipped with various graphics glitches that you could get in some combinations of map block configurations, position, and viewing angle.  Some were due to fixed point precision issues not being handled optimally, and some were due to clipping and culling issues that I didn’t really get a handle on until a couple years later.  In any case, they bothered me a lot.  Spurious graphics glitches do a lot of harm to the sense of immersion in a game, and I very much wanted Id games to feel “rock solid”.
 \bigskip \\
There was a clear performance cost to it – doing 320 traces through a tile map and treating each column independently is much slower than looping through a few long wall segments.  However, the resulting code was small and very regular compared to the hairball of my wall span renderers, and it did deliver the rock-solid feel I wanted.
 \bigskip \\
If you made extremely jagged block maps that would turn into many dozen independent wall segments, the ray casting could start to look like a good performance choice, but few scenes were even close to that.  This is exactly the same ray tracing versus rasterization performance tradeoff that is still being made today, but now it is “how many tens of millions of triangles per frame to ray tracing break-even” instead of “how many dozen wall segments”.
 \bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}
 

\end{document}

