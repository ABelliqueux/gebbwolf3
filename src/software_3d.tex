\section{Action Phase: 3D Renderer}
After the player is done setting up the game finally comes time for the 3D engine to shine. Here are the internals of something that was kep secret for many years. The 3D engine is based on raycasting technology which is simple yet powerful. The idea is to cast a ray for each column of pixel visible on the screen. Based on the distance d from the point of view to where the ray htis a wall, a height h can be calculated:\\
\par
\begin{figure}[H]
  \centering
  \begin{equation}
      \scalebox{2.0}{$h = \frac{X}{d}$}
  \end{equation}
\end{figure}
\par
Even for a complex scene involving multiple door and rooms, this method can delivers fast intersection calculations.
\par
\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/ray_caster_explained/out_room.pdf}
 \caption{Casting 320 rays (one for each column) for a screen of resolution 320x200} \label{fig:Raycasting2}
\end{figure}

\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/drawings/ray_caster_explained/out_door.png}
 \caption{Rendition of the height calculated from d (with texturing).} 
\end{figure}

The secret of Wolfesnstein 3D speed lies in two tricks (described in details later): Precompiled scalers and Deffered column rendering.


\subsection{Life of a frame}
As we saw when we unrolled the loop, the action scene is made of frames in a loop. In pseudo code:\\
\par
\begin{minipage}{\textwidth}
 \lstinputlisting[language=C]{code/flawded_game_loop.c}
 \end{minipage}
\par
Despite being state of the art for 1991, this architecture has a major flaw: Each slice of the game has a different duration which makes the game undeterministic from one machine to an other. Or even between two runs on the same machine.
\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/timer/wrong.pdf}
 \caption{Phase 1: Background}
 \end{figure}
  That is why it is not possible to record and replay a session. Upon replaying the game would reach a time where no inputs are available, resulting in different outcomes.\\
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/timer/replay.pdf}
 \caption{Phase 1: Background}
 \end{figure}
\par
To solve this problem during the demo, the game disregards the timer and simulate things at fixed timesteps.\\
\par
Doom in 1993 would solve this issue by simulating the world at fixed intervals:
\par
\begin{minipage}{\textwidth}
 \lstinputlisting[language=C]{code/fixed_game_loop.c}
 \end{minipage}
\par
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/timer/fixed.pdf}
 \caption{Phase 1: Background}
 \end{figure}

\subsection{Life of a 3D frame}
A 3D scene is rendered in four passes:
\begin{enumerate}
 \item Clear the screen by drawing the floor and the ceiling (both solid color).
 \item For each column of pixel on screen. cast a ray for each column of pixel from the player the wall. Draw a textured column of pixels inversely proportional to the distance.
 \item Draw the things (enemies, lamps, barrels).
 \item Draw the weapon.	
\end{enumerate}
Each of these passes are described later in details. This was just an overview.

During this process, all assets come from file VMSWAP (see Page Manager for more explanations)
\begin{enumerate}
	\item Textures for the wall are stored uncompressed.
	\item Sprites are ...They are not compressed per say but because they contain a lot of optimization: Own many columns to skip on the left. How wide they are. Since sprites are drawn as column....chunk offsets ahd chunk length. Sprites are drawn bottom up
\end{enumerate}
Following, screenshots of a slowdown version of the engine, showing each four step of rendition:
\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_1_background.png}
 \caption{Phase 1: Background}
 \end{figure}

\par
\begin{minipage}{\textwidth}
 \lstinputlisting[language=C]{code/vgaCeiling.c}
 \end{minipage}
\par
 


The floor was always the same color. The ceiling however changed see \codeword{WL\_DRAW.C} for a hard-coded index. TODO: Include a clear screen from a later level.\\
\begin{figure}[H]
 \centering
  \includegraphics[width=\textwidth]{screenshots/wolf3d_4_partial_wall_32rays.png}
  \caption{Phase 2: Walls (40 rays)}
 
\end{figure}
 
\begin{figure}[H]
 \centering
  \includegraphics[width=\textwidth]{screenshots/wolf3d_5_partialwalls_160rays.png}
 \caption{Phase 2: Walls (160 rays)} 
 
\end{figure}
 
 
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf4d_2_walls.png}
 \caption{Phase 2: Walls completed} 
 \end{figure}
 
 
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_6_scaled}
 \caption{Phase 3: Scaled (a.k.a: Sprites)} 
 \end{figure}

 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_7_fullframe.png}
 \caption{Phase 4: Weapon} 
 \end{figure}
 

   Synergy: VGA column drawing, raycasting, occlusion array\\


The static part (ammo, face, etc) is not redrawn if not necessary. However cost is high since the new part of the screen has to be draw in three buffers (e\.g:StatusDrawPic) .












\subsection{To Delete}
These three systems are amply described in the next sections. The most interesting one is of course the 3D renderer. It is in fact not really 3D: Maps are two dimensional and designed with square blocks.: e.g, the first level E1M1:\par

\par 
A 3D dimensional view of the 2D map is rendered at runtime:

\begin{figure}[H]
  \centering
 \fullimage{wolf3d_7_fullframe.png}
 \caption{As it is rendered at runtime in pseudo-3D from the player point of view.} 
\end{figure}

 The pseudo 3D is generated via a system of raycasting\footnote{Not to be confused with raytracing.}. The previous screenshot being 320 wide by 200 tall, it requested to cast 320 rays (one for each column of wall):

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{imgs/drawings/ray_caster_explained/beginning.pdf}
 \caption{Complex scene: 320 ray cast.} 
\end{figure}











\subsection{3D setup}
Before starting to draw frames, the 3D engine needs to setup VRAM with static elements. As you noticed the 3D view is not fullscreen. It is contained in a HUD\footnote{Head-up display}:
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{screenshots/hud_empty.png}
\end{figure}
This HUD is drawn only once at the beginning of the 3D phase. It has to be drawn in all three pages. For each new frame, the engine will draw the 3D view in the allocated region. The stats (Level, Score, Lives, Status, Health, Ammo, Current weapon) get a special treatment. In order to draw them as fast as possible they are uploaded to the VRAM (beyond the third page).\\
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/drawings/hud.pdf}
\end{figure}
Notice how blocks are aligned on 4 bytes horizontally but there is no restriction vertically: The VGA four banks constraints.
Sprites 91 to 134 are latched in VRAM.\\

\begin{minipage}{.23\textwidth}
     \fullimage{latched/91.png}
  \end{minipage}
\begin{minipage}{.23\textwidth}
     \fullimage{latched/92.png}
  \end{minipage}
\begin{minipage}{.23\textwidth}
     \fullimage{latched/93.png}
  \end{minipage}
\begin{minipage}{.23\textwidth}
     \fullimage{latched/94.png}
  \end{minipage}
\par


\begin{minipage}{.095\textwidth}
     \fullimage{latched/99.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/100.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/101.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/102.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/103.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/104.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/105.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/106.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/107.png}
  \end{minipage}
\begin{minipage}{.095\textwidth}
     \fullimage{latched/108.png}
  \end{minipage}
\par


\begin{minipage}{.3\textwidth}
     \fullimage{latched/109.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/110.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/111.png}
  \end{minipage}
\par



\begin{minipage}{.3\textwidth}
     \fullimage{latched/112.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/113.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/114.png}
  \end{minipage}
\par



  \begin{minipage}{.3\textwidth}
     \fullimage{latched/115.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/116.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/117.png}
  \end{minipage}
\par





  \begin{minipage}{.3\textwidth}
     \fullimage{latched/118.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/119.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/120.png}
  \end{minipage}
\par



  \begin{minipage}{.3\textwidth}
     \fullimage{latched/121.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/122.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/123.png}
  \end{minipage}
\par

    \begin{minipage}{.3\textwidth}
     \fullimage{latched/124.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/125.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/126.png}
  \end{minipage}
\par

    \begin{minipage}{.3\textwidth}
     \fullimage{latched/127.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/128.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/129.png}
  \end{minipage}
\par

    \begin{minipage}{.3\textwidth}
     \fullimage{latched/130.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/131.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/132.png}
  \end{minipage}
\par


\begin{minipage}{.1\textwidth}
     \fullimage{latched/95.png}
  \end{minipage}
\begin{minipage}{.1\textwidth}
     \fullimage{latched/96.png}
  \end{minipage}
\begin{minipage}{.1\textwidth}
     \fullimage{latched/97.png}
  \end{minipage}
\begin{minipage}{.1\textwidth}
     \fullimage{latched/98.png}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
     \fullimage{latched/133.png}
  \end{minipage}
\begin{minipage}{.3\textwidth}
     \fullimage{latched/134.png}
  \end{minipage}\

Why is it faster to copy from VRAM to VRAM instead of RAM to VRAM? Because the VGA latches system allows to read and write four pixel at a time.\\
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/latches_drawing.png}
 \end{figure}
 By configuring the read operations to read from all banks and configuring the write operations to use the latched value.

Not at fast as it seems since things have to be drawn in all three buffers during action 3D phase:\\
\par

\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/StatusDrawPic.c}
\end{minipage}


LatchDrawPic
Chapter 48 from michael abrash book
atches were not intended for use in 256-color mode; that was something I figured out as a hack and wrote about. The latches were used so that in 16-color mode any or all of the four planes could be written to at once.




All these assets account for $48*24*4+14*8*16+23*24*32+224*48=34,816$ bytes. There is therefore $2^18-320*208*3 - 34,816=27,648$ bytes unused VRAM in the VGA.
All these assets are used with the VGA in order to copy 4 pixels at a time.


\subsection{Clearing the screen}
At the beginning of very frame, the engine switch to an unused buffer (TODO: show triple buffering in action) and clear it. To this effect, it uses the latch seen in the 2D renderer: 









\subsection{Solving the CPU problem}

The hardware chapter describing the CPU capabilities left the reader with a problem at hands: The machine cannot do floating point operations fast enough. This is a pretty big deal for a 3D engine and all the trigonometry involved. It turns out the solution is to trick the ALU via a technique called "fixed point arithmetic".







\subsubsection{Fixed point}
The normal layout of an \cw{int} is as follow:
\begin{figure}[H]
\centering
 \input{imgs/drawings/int.tex}
 \caption{Integer layout.} \label{fig:int_layout}
 \end{figure}
The value of the sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
\centering
\input{imgs/drawings/int_example.tex}
 \caption{Integer example.} \label{fig:mips}
 \end{figure}

 Is equal to $ 2^{13} + 2^9 + 2^5 + 2^1 =  8738 $.\\
 \par

Fixed Point allows to keep track of fractions while still using the integer operations of the CPU. The machine manipulates what are supposed to be integer numbers but the programmers sees them as a value containing an integer part and a fractional part:\\
\par
\begin{figure}[H]
 \centering
  \input{imgs/drawings/fp.tex}
 \caption{Fixed point layout 8:8 (8bits for integer part and 8 bits for fractionnal part).} \label{fig:mips}
\end{figure}

So the same sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
 \centering
   \input{imgs/drawings/fp_example.tex}
  \caption{Fixed point representation: 8738 is now 34.1328125.} \label{fig:mips}
\end{figure} 

Now represents:\\
\\
$ 2^5 + 2^1 = 34 $ for the integer part.\\
$ 2^{-3}+2^{-7} = 0.1328125 $ for the fractional part.\\
$ = 34.1328125$\\

\bigskip

The beauty of fixed point is that addition and subtraction work exactly like integers from the CPU instruction side:\\




\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/34_75.tex}

   \caption{34.75} 
\end{figure} 

\begin{figure}[H]
 \centering
   \input{imgs/drawings/1_5.tex}
  \caption{+ 1.5} 
\end{figure} 

\begin{figure}[H]
 \centering
   \input{imgs/drawings/36_25.tex}
  {\caption{= 36.25}}
\end{figure} 
\par
\par


 The special case is when performing multiplication. There are two ways to do it: Either multiply two 32 bits into a 64 bits or drop the precision of both fixed point and multiply then into a 32 bits. Since the 286 and 386 do not have 64 bits registers, wolf does the later (illustred here with 8:8 for readability):


\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/98_7539.tex}
   \caption{98.7539} 
\end{figure} 
\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/1_5.tex}
   \caption{* 1.5} 
\end{figure} 
\par
First right shift both operators:\\
\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/rs_98_7539.tex}
\end{figure} 
\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/rs_1_5.tex}
\end{figure} 
\par

Finally multiply them together:

\begin{figure}[H]
 \centering
   \input{imgs/drawings/148_125.tex}
   \caption{148.125} 
\end{figure} 
$128 + 16 + 4 + 0.125 = 148.125 $


Notice that you have to be careful: In the previous example some precision was lost ($ 2^{-8}$) bit disappeared during the $\gg 4$ operation) and an overflow could have occured (multiplying by 3 would have gone past the precision of 8:8). But with this system, fractions are possible and fast enough!\\
\par
\begin{minipage}{\textwidth}
 \lstinputlisting[language=C]{code/fixed_mul.c}
 \end{minipage}
\par
 \textbf{\underline{Trivia :}}  Fixed Point Arithmetic usage was not limited to PC gaming. Many game console manufactured in the 90s and later had no hardware floating point unit: Sony's original PlayStation (1994) and Sega's Saturn (1994) are examples among many with a design choice that not only reduced the production cost but also maximized the CPU pipeline throughput.
 
 Even right shit and left shift trick work:\\
 
 \par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/1_5.tex}
   \caption{1.5} 
\end{figure} 

\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/3.tex}
   \caption{1.5 << 2  = 3} 
\end{figure}

\par
\begin{figure}[H]
 \centering
   \input{imgs/drawings/0_75.tex}
   \caption{1.5 >> 2 = 0.75} 
\end{figure}


 

 E.G: Player position is 16:16, to get grid location just remove fraction part player->x >> 16.
 
 


\subsubsection{Coordinate System}
\par
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/drawings/coordinate_system.png}
\end{figure}
\par
calcheigh is using 24:8 ?


\subsubsection{Square World and RayCasting}
\bu{Trivia :}In Wolfenstein3D all blocks are cubes 8 feet by 8 feet by 8 feet.

With fraction possible, the engine still needs to find a way to render the walls in pseudo-3D. Per say, draw a wall bigger if it is closer and smaller if it is far. To do that, it cast a ray for each column of pixel on the screen. With the distance it calculates a height on screen.\\
\par
To cast a ray and find the intersection, if the word is made of various shapes with no constraints, the cost is high:\\
\par
DRAWING: Free objects, free size, no aligment: rays ???\\
\par
But if the word has two constraints:
\begin{itemize}
\item Square axis aligned block: 8feet tall. TODO: How is the engine translating from imperial to decimal system?
\item Grid space blocks.
\end{itemize}
\par
The problem becomes much simpler:\\
\par
\begin{figure}[H]
\centering
 \input{imgs/drawings/casting_a_ray/situation.tex}
\end{figure}

With a naive approach we could check for intersection at a regular interval. As the two rays draws below, it would works for some rays and fail for most of them.
\begin{figure}[H]
\centering
 \input{imgs/drawings/casting_a_ray/unaligned.tex}
 \caption{blabla.}
\end{figure}

The solution for 100\% accuracy is to check for 'hit` when the ray cross the grid. This is why Wolfenstein 3D could only draw walls on a perpendicular grid.
\begin{figure}[H]
\centering
 \input{imgs/drawings/casting_a_ray/fixed.tex}
 \caption{blabla.}
\end{figure}
\par
DDA Algorythm:
 \par
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/drawings/dda_explainer.png}
\end{figure}
\par

This way is fast. For the ray above, only four intersections checks had to done. For the one below only 3.\\
\par
And this explains why Wolfenstein3D maps are all flat, 64x64 grid aligned square blocks:\\
\par

\begin{figure}[H]
  \centering
 \fullimage{e1m1.png}
 \caption{The legendary E1M1. Player is the green arrow at the bottom.}
\end{figure}




\subsubsection{Call Apogee}
With map being simple and fast to draw, a contest was to be held: Find a special item in a particularly difficult to access place in the game and call the publisher (Apogee). The maze is located in Episode 2, Map 8:\\
\par
\begin{figure}[H]
  \centering
 \fullimage{e2m8.png}
\end{figure}

\par
Behind a forest of push walls (white squares) and angry bosses (blue star), a sign finally showed up (the red triangle in the map above):\\
\par

\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{screenshots/call_apogee.png}
\end{figure}
\par
However due to people reverse engineering the map format and cheat sites allowing players to find the maze, the sign was replaced with a squeleton with all game shipping during 1992.
\par
\begin{fancyquotes}
"Call Apogee and say Aardwolf."  It's a sign that to this day is something
that I get asked about a lot.  This is a sign that appears on a wall in a
particularly nasty maze in Episode 2 Level 8 of Wolfenstein 3D.  The sign
was to be the goal in a contest Apogee was going to have, but almost
immediately after the game's release, a large amount of cheat and mapping
programs were released.  With these programs running around, we felt that
it would have been unfair to have the contest and award a prize.  The sign
was still left in the game, but in hindsight, probably should have been
taken out.  To this day, Apogee gets letters and phone calls and asking
what Aardwolf is, frequently with the question, "Has anyone seen this yet?"\\
\\
Also, in a somewhat related issue, letters were shown after the highest score
in the score table in some revisions of the game.  These letters were to be
part of another contest that got scrapped before it got started, where we were
going to have people call in with their scores and tell us the code; we'd then
be able to verify their score.  However, with the cheat programs out there,
this got scrapped too.\\
\\
Basically, "Aardwolf" and the letters mean nothing now.  Also note that if
you found the Aardwolf sign in the game (without cheating), there's a VERY
strong chance that you're stuck in there.  The only way out may be to restart,
or load a saved game from before you went into that maze.\\
\\
\textbf{Joe Siegler - Past Pioneers of the Shareware Revolution}
\end{fancyquotes}
\par
Aardwolf. A maned striped mammal (Proteles cristatus) of southern and eastern
Africa that resembles the related hyenas and feeds chiefly on carrion and insects.
The aardwolf has sort of become the mascot of Id, appearing on Tom's Gotta
Lists and the Commander Keen 6 Hint Sheet.














 
 
 
 
 
 
 
 
\subsubsection{Raycasting: DDA Algorithm}
The raycasting algorithm is calld DDA\footnote{Digital Differential Analysis, commonly used in CG world to draw a line.}. It is a fully handcrafted 740 lines of assembly routine name \cw{PROC AsmRefresh}. Represented in C for readability it consists of two while looks (one checking vertical intersection and one checking the horizontal) ping-ponging with each other via goto. It is highyt unorthodox and super efficient:\\
\par

\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/flipflop.c}
\end{minipage}

\bu{Trivia:} To accelerate \cw{cos} and \cw{sin} calculation, the engine uses lookup table: One entry for each 360 degres.




\begin{fancyquotes}
Why a raycaster instead of a rasterizer?\\
\par
Much was made about the "ray casting" used in Wolfenstein, but the real reason for it was that I had a lot of trouble with wall-span rendering in Catacombs 3D.  C3D (and Hovertank before that) shipped with various graphics glitches that you could get in some combinations of map block configurations, position, and viewing angle.  Some were due to fixed point precision issues not being handled optimally, and some were due to clipping and culling issues that I didn't really get a handle on until a couple years later.  In any case, they bothered me a lot.  Spurious graphics glitches do a lot of harm to the sense of immersion in a game, and I very much wanted Id games to feel "rock solid".
 \bigskip \\
There was a clear performance cost to it - doing 320 traces through a tile map and treating each column independently is much slower than looping through a few long wall segments.  However, the resulting code was small and very regular compared to the hairball of my wall span renderers, and it did deliver the rock-solid feel I wanted.
 \bigskip \\
If you made extremely jagged block maps that would turn into many dozen independent wall segments, the ray casting could start to look like a good performance choice, but few scenes were even close to that.  This is exactly the same ray tracing versus rasterization performance tradeoff that is still being made today, but now it is "how many tens of millions of triangles per frame to ray tracing break-even" instead of "how many dozen wall segments".
 \bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}







\subsubsection{HighSchool math primer}
Before proceeding to the next session about fish eye projection correction, here is a reminder of something we all learned in highschool: SOH-CAH-TOA.

 \begin{fancyquotes}
  I'm no super mathematician-- I learned high school math well enough to solve real world problems with it.\\
 \par
\textbf{John Carmack - Programmer}
 \end{fancyquotes}


\par
\begin{figure}[H]
\centering
 \input{imgs/drawings/soh-cah-toa.tex}
\end{figure}

This property is multiple places:\\
This is all you need to understand fish eye correction and coordinate projection (used to place player, and calculate sounds).












\subsubsection{FishEye}
With a fast way to find the intersection between a ray and the walls, the distance is calculated in \cw{CalcHeight}:\\

\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/CalcHeight.c}
\end{minipage}

The code is not what one would expect: The raycasting algorithm is supposed to cast a ray for each pixel column and use the distance \codeword{d} to infer the column's heigh on screen. So one would have expected to see a formula like:
$ d = \sqrt{dx^2 + dy^2}$ . But instead it looks like: $d = dx * \cos(\alpha) - dy * \sin(\alpha) $! Something is fishy here ;) !\\
\par
\begin{figure}[H]
\centering
 \input{imgs/drawings/fish_eye/state.tex}
 \caption{Raycasting using distance d} \label{fig:Raycasting2}
\end{figure}

In this drawing the player is located at viewpoint with a view angle \begin{math}\alpha\end{math}. The distance \codeword{d} is a straight line between the player point of view and the location where the ray hit the line which can be obtained with $d = \sqrt{dx^2 + dy^2}$. Such an algorithm would result in a "fisheye effect". It is not very noticeable when a wall is far:

\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/fish_eye/bad_mild.png}
 \caption{Fish eye effect: Mild}. \label{fig:mips}
 \end{figure}








\begin{minipage}{.7\textwidth}
But it gets worse when you get closer:
 \end{minipage}
\begin{minipage}{.3\textwidth}
\begin{figure}[H]
  \begin{flushright}
 \includegraphics[width=\textwidth]{imgs/drawings/fish_eye/fish_eye_top_far.png}
   \end{flushright}
\end{figure}
\end{minipage}

\par



\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/fish_eye/bad_ok.png}
 \caption{Fish eye effect: Bad} \label{fig:mips}
 \end{figure}




\begin{minipage}{.7\textwidth}
And become unbearable when very close:
 \end{minipage}
\begin{minipage}{.3\textwidth}
\begin{figure}[H]
  \begin{flushright}
 \includegraphics[width=\textwidth]{imgs/drawings/fish_eye/fish_eye_top_mid.png}
 \end{flushright}
\end{figure}
\end{minipage}






 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/fish_eye/bad_bad.png}
 \caption{Fish eye effect: AAAAARG} \label{fig:mips}
 \end{figure}
 

\begin{minipage}{.7\textwidth}
To avoid this distortion and get a more pleasant rendition, what must be used is not the direct distance d but d projected on the perpendicular of the view direction (z):
 \end{minipage}
\begin{minipage}{.3\textwidth}
 \begin{figure}[H]
  \begin{flushright}
 \includegraphics[width=\textwidth]{imgs/drawings/fish_eye/fish_eye_top_close.png}
 \end{flushright}
\end{figure}
 \end{minipage}

\par



\begin{figure}[H]

 \input{imgs/drawings/fish_eye/d_vs_z.tex}
 \caption{blabla.} \label{fig:Raycasting2}
 
\end{figure}


This projection (z) is mathematically hard to calculate in one go (especially with fixed point). The trick is to break it down in two components and use your highschool mnemonic: SOH-CAH-TOA!\\

\begin{figure}[H]
\centering
 \input{imgs/drawings/fish_eye/correct_way.tex}
 \caption{A combination of SOH A=($dx * \cos(\alpha)$) and CAH B=($ dy * \sin(\alpha) $) gives $d = dx * \cos(\alpha) - dy * \sin(\alpha) $ gives the expected result.}
\end{figure}


The overall operation can be seen as a rotation of y intercept around the viewpoint.\\
 Which is enough to give pleasant straigh lines. Following a wall uncorrected and the same location with projected distance:


 \begin{figure}[H]

 \includegraphics[width=\textwidth]{screenshots/fish_eye/fish_eye.png}
  \caption{Fish eye: Uncorrected} 
  
 \end{figure}

  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/fish_eye/fish_eye_corrected.png}
\caption{Fish eye: Corrected} 
 \end{figure}
 \par
 An other example with the starting screen:\\
 \par
  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/fish_eye/fish_eyed_start_screen2.png}
  \caption{Fish eye: Uncorrected} 
 \end{figure}
 \par

  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_7_fullframe.png}
  \caption{Fish eye: Corrected} 
 \end{figure}
 \par
 \bu{Note :} Why substract values instead of adding them ? The coordinate system has its origin at the upper left which inverse the vertical axis and therefore the sin value. To compensate for it, the formula substract the negative value, resulting in an addition.













\subsection{Drawing walls}
Drawing the wall may sound easy. After how complicated can it be to scale a 64 pixels tall texture on the screen, centered vertically? It turns out if you want to do it fast you can apply a few optimization. This part is where lies the two secrets of the engine speed: Compiled scalers and defered column rendering.\\
\par
Walls are eight feet thick
\par

\subsubsection{Compiled scalers}
With a distance available for a column, the engine is able to calculate a height for that column. All columns of pixels representing the walls are centered vertically and either magnified or minified:\\
\par
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/scaler_valign.png}
 \end{figure}
\par

The naive approach would be to use a generic routine:\\
\begin{verbatim}
void drawRoutine(int height, void* src, void* dst) {
  
}
\end{verbatim}
\par
But that would be a lot of instruction for sometimes only a few pixels generated. There is a faster way: Generate code specialized to drawing all height of wall from 1 pixels to 200 (the height of the screen).\\
\par
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/scaling_walls.png}
 \end{figure}
\par
Everything not between the pink lines (64 pixels tall) is either minified or magnified. It is a significant task to perform at runtime, involving fraction (of course done via fixed point arithmetics). To speed up this phase, the engine generate executable x86 code when the screen size is set (at startup or upon user choices).
TODO: Show a lower resolution photo.\\
TODO: Show precompiled scaler ram consumption.\\
Every column of pixels are centered vertically.



TODO: Pseudo-code here\\
\par
Builds a compiled scaler object that will scale a 64 tall object to the given height (centered vertically on the screen).
\codeword{SetupScaling}\\
\codeword{BuildCompScale}
Trivia: What as the memory budget of the scaller? JC had to cut corners. What was the cost before cutting corners.\\
\par
\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/compscale.c}
\end{minipage}

\par
Is the tradeof speed/memory worse it for compiled scalers ? How much RAM does it use? According to the code sample, it takes 7 instructions of one byte each to write a pixel. So if all size were generated from 2,4,6...152, we could use Gauss method to calculate the size:\\
\par
$154*38*7=40,964$ bytes\\
\par
That cost was deamed too high, so past size 76 only every other size are generated (2,4,6,,..,72,74,76) and (78,82,86,...,144,148,152):\\
\par
$78*19*7+9*230*7=26,474$ bytes\\
\par











\subsubsection{Defered drawing:}
A naive implementation of the raycaster would be:\\

\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/naive_raycaster_pseudocode.c}
\end{minipage}
\par
But the engine is different: It buffers what to draw:\\
\par
\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/wolf3d_raycaster_pseudocode.c}
\end{minipage}

\par
Notice how a frame is stored in a page across four banks. Horizontally it looks a little bit like mashed potatoes:
 \begin{figure}[H]
\centering
 \fullimage{vga_layout/intro.png}
 \caption{Intro screen as it appear on screen}
 \end{figure}
 \par
 \begin{figure}[H]
\centering
 \fullimage{vga_layout/intro_bank.png}
 \caption{Intro screen as it is stored across 4 banks in a framebuffer} \label{fig:vga_layout_for_intro}
 \end{figure}
\par
An other example during a 3D sequence.
\begin{figure}[H]
\centering
 \fullimage{vga_layout/wolf3d_7.png}
 \caption{3D View as is appears on screen} \label{fig:vga_layout_in_3D}
 \end{figure}
 \par

 \begin{figure}[H]
\centering
 \fullimage{vga_layout/wolf3d_7_bank.png}
 \caption{3D View as it is stored across 4 banks in a framebuffer}
 \end{figure}
But vertically each bank stores a column intact. This is an important property which is exploited later during the game.
\par


Rendition is deferred because the engine allows itself to cheat a little: If a ray is cast and hits the same block and in the same
texture column, the two rays are considered similar. If two rays are similar they are drawn at the same height. The visual result is 
barely noticable. But this cheat allows to draw up to eight column of pixel in three write operations (in practice it is more like two columns
with one write operation). The details of this are in the method \codeword{ScalePost} in \codeword{WL\_DRAW.C}.\\

Note: A \quotes{post} is a column of pixel belonging to a wall.\\
ScalePost is written in assembly and performs a maximum of three pass to draw a maximum of eight columns of pixels.\\
\par 
\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/ScalePost.c}
\end{minipage}
Because there can be many combinations of VGA bank alignment and number of pixels to draw:

\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/mask_banks.pdf}
 \end{figure}



\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/drawings/scalePost_explanation1.pdf}
 \end{figure}
 
 \begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/drawings/scalePost_explanation2.pdf}
 \end{figure}

  \begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/drawings/scalePost_explanation3.pdf}
 \end{figure}

  \begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/drawings/scalePost_explanation4.pdf}
 \caption{Passes: 8,15,14}
 \end{figure}

   \begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/drawings/scalePost_explanation5.pdf}
  \caption{Passes: 15,3,0}
 \end{figure}


The instruction \codeword{or al , al} can be surprising. It means test if al is equal to zero and set the flag. Back in the day it was more populate than \codeword{test al, al}
 the VGA bank masks are harcoded in an array: One for each pass:\\
 \par
 \begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/hardcoded_masks.c}
\end{minipage}
TODO: Were images stored rotated 90degres to increase cache hit ? No way, this was aimed at 386. BUT that would make the drawing easier !!

In the following example, the left wall is magnified. several rays hit the wall at the same texture location.
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/post_optimization_1_pink_show.png}
\end{figure}
The engine takes advantage of it and draw several columns (posts) efficiently with the VGA. The engine was altered to show the optimized posts in pink.
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/post_optimization_1_show.png}
\end{figure}

In the previous scene, 20\% of the wall was optimized away. In the next two screenshot, the same process, this time with the `eagle' texture:
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/post_optimization_2_show.png}
\end{figure}


\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/post_optimization_2_pink_show.png}
\end{figure}
 
To draw several column of pixels at the same time, the engine exploit the VGA banks and the masking mechanism seen in the Hardware section.
Since up to eight column can be similar, there are many case of figure depending on the aligment with the VGA banks and how many pixels to draw:

Example























\subsubsection{Texturing}
A subtle but extremely efficient trick used to improve rendition is pre-back light texture. The wall textures are generated twice by the artists: Once light and once dark:\\
  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/baked_lights_wood.png}
 \end{figure}
\par
  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/baked_lights_stone.png}
 \end{figure}
\par
At runtime, upon casting each ray: if the ray hit a vertical wall the engine uses a light texture. If the ray hits an horizontal wall, it uses the dark version of the same texture. it is not obvious but when the same scene is rendered with and without and both screenshots are next to each others, the difference is vivid:\\
\begin{minipage}{\textwidth}
\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/backed_off.png}
 \caption{Here: Backed texture off. Next: Backed texture on.}
 \end{figure}

\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/backed_on.png}
 
 \end{figure}
 \end{minipage}




 





\subsubsection{Door}
Doors have no tickness.\\
doorposition[] holds the amount the door is open, ranging from 0 to 0xffff
  this is directly accessed by AsmRefresh during rendering\\
  // don't close on anything solid\\
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/door_flat.png}
\end{figure}

\par
TODO: Explaih half step added.\\
\par 
 \par
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/drawings/test_door.png}
\end{figure}
\par












\subsubsection{Push walls} 
Push walls are very similar to doors except they "open" away from the player instead of sideway.\\
\par
Tom had to really push to get pushwalls (hidden walls).\\


















\subsection{Drawing things}
To determine what is visible and draw things properly is hard. Michael Abrash summarized the domain of the problem well:\\

\begin{fancyquotes}
I want to talk about what is, in my book, the toughest 3-D problem of all, visible surface determination (drawing the proper surface at each pixel), and its close relative, culling (discarding non-visible polygons as quickly as possible, a way of accelerating visible surface determination). In the interests of brevity, I’ll use the abbreviation VSD to mean both visible surface determination and culling from now on.
 \bigskip \\
Why do I think VSD is the toughest 3-D challenge? Although rasterization issues such as texture mapping are fascinating and important, they are tasks of relatively finite scope, and are being moved into hardware as 3-D accelerators appear; also, they only scale with increases in screen resolution, which are relatively modest.
 \bigskip \\
In contrast, VSD is an open-ended problem, and there are dozens of approaches currently in use. Even more significantly, the performance of VSD, done in an unsophisticated fashion, scales directly with scene complexity, which tends to increase as a square or cube function, so this very rapidly becomes the limiting factor in doing realistic worlds. I expect VSD increasingly to be the dominant issue in realtime PC 3-D over the next few years, as 3-D worlds become increasingly detailed.
 \bigskip \\
\bigskip \\
\textbf{Michael Abrash - Programmer}
 \end{fancyquotes}
 
 Wolf3D uses two mechanism to make sure things are draw properly:
 \begin{enumerate}
  \item While casting each ray, memorize which cells were visited by the ray. This is used to know which "things" to draw.
  \item Upon drawing a wall column, save the height of that wall. This is done to clip "things" to draw.
 \end{enumerate}
 


 At the beginning of each 3D rendition, the engine clears the:
 \lstinputlisting[language=C]{code/clear_vis_wold3d.c}
 Note that because register are 2 bytes wide, an array of 64x64=4096 bytes can be zeroed in 2048 iterations. Nowadays it is more efficient to use the C library.
 \lstinputlisting[language=C]{code/clear_vis_modern.c}
 Later in the assembly hand crafted procedure \codeword{AsmRefresh} we can find where this array is populated:
  \lstinputlisting[language={[x86masm]Assembler}]{code/mark_vis_wold3d.asm}
  If we take the example of the starting screen, we can see which tile were marked at visible:
  
  
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{imgs/drawings/ray_caster_explained/marked_out_room.pdf}
 \caption{Ray cast and visible spots.} 
\end{figure}

\par
MAXVISABLE=50\\
\par


Note that the engine does not place things vertically. They are always centered vertically. The artists cleverly drew the sprites not centered vertically but at the bottom of each images. This allows for a non-expensive perspective effect even though all sprites are vertically aligned.
\par
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/drawing_things.png}
\end{figure}
\par


  \begin{figure}[H]
\centering
 
 \caption{3D Rendere Phase 1: Backed lights} \label{fig:backee_lights}
 \end{figure}


\par
Since wall and sprites are all in the same referencial (64x64), it is easy to clip: For each column just compare the heigh from the occlusion array to the height of the thing:\\
\par
  \begin{minipage}{.5\textwidth}
     \includegraphics[width=\textwidth]{screenshots/guard_sprite.png}
  \end{minipage}
   \begin{minipage}{.5\textwidth} 
     \includegraphics[width=\textwidth]{screenshots/wall_texturw.png} 
   \end{minipage}

\par

  \begin{minipage}{.5\textwidth} 
     \includegraphics[width=\textwidth]{screenshots/sprite_food.png} 
   \end{minipage}
  \begin{minipage}{.5\textwidth} 
     \includegraphics[width=\textwidth]{screenshots/light_sprite.png}
   \end{minipage}

\par

Trivia: The sprites with a lot of transparency (such as the food and the lamp shown previously) would later turn out a major fillrate issue with hardware accelerated renderer for the iOS port:

\begin{fancyquotes}
Wolfenstein (and Doom) originally drew the characters as sparse stretched columns of solid pixels (vertical instead of horizontal for efficiency in interleaved planar mode-X VGA), but OpenGL versions need to generate a square texture with transparent pixels.  Typically this is then drawn by either alpha blending or alpha testing a big quad that is mostly empty space.  You could play through several early levels of Wolf without this being a problem, but in later levels there are often large fields of dozens of items that stack up to enough overdraw to max out the GPU and drop the framerate to 20 fps.  The solution is to bound the solid pixels in the texture and only draw that restricted area, which solves the problem with most items, but Wolf has a few different heavily used ceiling lamp textures that have a small lamp at the top and a thin but full width shadow at the bottom.  A single bounds doesn't exclude many texels, so I wound up including two bounds, which made them render many times faster. 
\bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}

TODO: Elaborate on drawing routines which uncompresse sprites on the fly.


\subsubsection{Clipping}
Drawing things far to near is good for transparency but does not guaranty correctness. When a sprite is partially behind a wall or a door, it has to be clipped. This is done thanks to an occlusion array: While drawing the walls and door, the engine also maintains an array in which it records the height of the column:\\
\par
\begin{minipage}{\textwidth}
\lstinputlisting[language=C]{code/wallheight.c}
\end{minipage}
\par
Since all sprite and walls are in the same coordinate system, clipping is as easy as a heigh comparaision:\\
















\subsection{Drawing weapon}
Drawing the weapon at the bottom is very straight forward. It just uses the precompiled scalar with no clipping. Nothing much to say abou that :/!\\
\bu{Trivia :} About damage of machine gun?








\subsection{A.I}
The 3D engine not only draw things, it also allows all objects to "think": Those thinking objects are called "actors" and help to keep the game exciting and improve immersion. If enemies are too predictable and easy to defeat the game is boring. The designer and programmers worked in tandom on this one: The engine maintains a stae machine for each thinker but it also relies heavily on hints and clues on the map provided by the designers.\\
\par







"Actors" are what make Woflenstein3D exciting. They can be agressive, they can be sneaky and they can be dumb (like when they are a door). Without them the game would be a beautiful and boring maze. The game designer and developers did a great job.\\
\par
In the engine, an actor is a state machine with four states:
\begin{itemize}
\item Standing
\item Attack
\item Pursuit
\item Retreat
\end{itemize}
\par
TODO: Draw a state machine of a guard, starting at \cw{T\_Stand} and moving to \cw{SightPlayer}, \cw{T\_Attack}.
\par
What makes enemies interesting to interact with is how the go from standing to being agressive. They have three ways to detect the player:\\
\begin{itemize}
\item Proximity
\item Vision
\item Sound
\end{itemize}
By far the sound is the most important and what makes the player feel like the A.I is smart. Sound propagation has always been well done in id Software engines (from wolf to doom3) yet received little coverage.

\subsubsection{Patrolling}
I/A also faked with map waypoint for patrolling.\\








\subsubsection{Sound propagation reaction}
Early one the game teaches the player that enemies will react to gunfire and seek where the sound was coming from. Sound is an essential part of the experience. The engine takes care of it in a simple and resource efficient way: Maps are preprocessed, with each room defining an area. At runtime, the engine keeps track of what door opens and what door closes and maintains a matrix of portal connecting areas.
Knowing if an ememy can hear the main character gunfire is a simple lookup in a table.

\par
\begin{figure}[H]
 \centering
 \includegraphics[width=.75\textwidth]{imgs/drawings/sound_area/map.pdf}
\end{figure}
\par

\par
\begin{figure}[H]
 \centering
 \includegraphics[width=.75\textwidth]{imgs/drawings/sound_area/area.pdf}
\end{figure}
\par


\par
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/drawings/soud_propagation/areaconnect.png}
\end{figure}
\par

\par
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/drawings/soud_propagation/areabyplayer.png}
\end{figure}
\par









However this is a simple model. When a gun is fired, all enemies which could hear it will shout "Achtung!" (Attention!") and converge toward the origin of the sound. That would get old pretty fast. So the designers introduced a little hack that goes a long way.

\par
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/ambush/map_unknown.png}
\end{figure}
\par

\begin{minipage}{0.6\textwidth}
Some tiles in the map can be marked as "AMBUSH" tile. If a guard is standing on it, he will NOT react to sounds. He is deaf. Or smart if you prefer. This is introduced early on in E1M1, the character just neutralized an enemy in a corridor. At this point it has never encountered an ambush so the player assumes the area is clear:\\
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright}
\includegraphics[width=0.98\textwidth]{imgs/drawings/ambush/map_unknown_drawing.pdf}
\end{flushright}  
\end{minipage}
\noindent
\\


\par
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{screenshots/ambush/map_ambushed.png}
\end{figure}
\par
\begin{minipage}{0.6\textwidth}
So the player will relax and either go straight to the door or maybe go left (or worse: right) to see what is in these corners. And bam: AMBUSH.
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright}
\includegraphics[width=0.98\textwidth]{imgs/drawings/ambush/map_ambushed_drawing.pdf}
\end{flushright}
\end{minipage}
\noindent
\\

This is probably one of the cheapest feature in the engine which yet resulted in what most would agree is the soul of the game: Immersion.\\
\par

\bu{Trivia :} The ambush behavior is explained in the Hint Book as follow:\\
\par
\begin{fancyquotes}
Each enemy is given specific orders which dictate his actions once he knows of your presence. Some are ordered to immediately attack, while others are trained to act only upon visual contact.
 \bigskip \\
\bigskip \\
\textbf{Kevin Cloud. The Official Hint Manual for Wolfenstein 3D}
 \end{fancyquotes}

\bu{Trivia :} Bug or dedication to ambush, a guard on a n AMBUSH tile will react ONLY to the player sight. Seeing an other actor die in front of him will not activate him.\\

\subsubsection{Vision reaction}
\subsubsection{Proximity reaction}
\subsection{Pursuit and opening doors}

\subsubsection{Firing at player}






