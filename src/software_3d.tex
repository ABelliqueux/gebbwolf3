\section{Action Phase: 3D Renderer}

\subsection{Big Picture}

During action sequences, the 3D scene is rendered in four passes:
\begin{enumerate}
 \item Clear the screen by drawing the floor and the ceiling (both solid color).
 \item Cast up to 320 rays and draw then according to the distance from the player.
 \item Draw the things (enemies, lamps, barrels).
 \item Draw the weapon.	
\end{enumerate}

Assets come from file VMSWAP:
\begin{enumerate}
	\item Textures for the wall are stored uncompressed.
	\item Sprites are ...They are not compressed per say but because they contain a lot of optimization: Own many columns to skip on the left. How wide they are. Since scprite are drawn as column....chunk offsets ahd chunk length. Sprites are drawn bottom up
\end{enumerate}
Following, screenshots of a slowdown version of the engine, showing each four step of rendition:
\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_1_background.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
The floor was always the same color. The ceiling however changed see \codeword{WL\_DRAW.C} for a hard-coded index. TODO: Include a clear screen from a later level.\\
\begin{figure}[H]
 \centering
  \includegraphics[width=\textwidth]{screenshots/wolf3d_4_partial_wall_32rays.png}
  \caption{3D Rendere Phase 2: Walls (160 rays)}
  \label{fig:mips}
\end{figure}
 
\begin{figure}[H]
 \centering
  \includegraphics[width=\textwidth]{screenshots/wolf3d_5_partialwalls_160rays.png}
 \caption{Finalez frame} 
 \label{fig:mips}
\end{figure}
 
 
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf4d_2_walls.png}
 \caption{3D Rendere Phase 2: Walls completed} \label{fig:mips}
 \end{figure}
 
 
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_6_scaled}
 \caption{3D Rendere Phase 3: Scaled} \label{fig:mips}
 \end{figure}

 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{screenshots/wolf3d_7_fullframe.png}
 \caption{3D Rendere Phase 2: Weapon} \label{fig:mips}
 \end{figure}
 

   Synergy: VGA column drawing, raycasting, occlusion array\\


The static part (ammo, face, etc) is not redrawn if not necessary. However cost is high since the new part of the screen has to be draw in three buffers (e\.g:StatusDrawPic) .



\subsection{Clearing the screen}
Screen is never actuall cleared like in modern engines. Instead a floor color and a ceiling color are drawn.






\subsection{Casting a Ray}
To explain how a ray is traced up to its interception point (a wall), let's take the example of a player looking at 15 degres. Three tiles will be seen, in the engine, up to 320 ray have to be cast to find out how far the post are and how tall they should be drawn.
\begin{figure}[H]
\centering
 \input{imgs/casting_a_ray/situation.tex}
\end{figure}


With a naive approach one could check for intersection at a regular interval. As the two rays draws below, it would works for some rays and fail for most of them.
\begin{figure}[H]
\centering
 \input{imgs/casting_a_ray/unaligned.tex}
 \caption{blabla.}
\end{figure}

The solution for 100\% accuracy is to check for 'hit` when the ray cross the grid. This is why Wolfenstein 3D could only draw walls on a perpendicular grid.
\begin{figure}[H]
\centering
 \input{imgs/casting_a_ray/fixed.tex}
 \caption{blabla.}
\end{figure}









\subsection{Loading Screen}
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/get_psyched.png}
\end{figure}
PM\_Preload()

Raycasting DDA: "http://lodev.org/cgtutor/raycasting.html"

\subsection{Map}
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/e1m1.png}
 \caption{The legendary E1M1. Player is the green arrow at the bottom.}
\end{figure}

Show 64x64.\\
Show angle orientation.\\

Map are plane based. Wolf3D have two planes. Plane \#0 stores walls, doors and ambush markers (ambush markers are explained in the I\.A section. Plane \#1 stores actors.\\

Maps are stored compressed RLEWed and then Carmackized.\\
To uncompress they have to be UnCarmackized and then unRLEWed.


Call apogee:\\
\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/call_apogee_texture.png}
 \caption{Raycasting 2: Call apogee texture} \label{fig:callapogeesprite}
\end{figure}

\begin{figure}[H]
  \centering
 \includegraphics[width=\textwidth]{imgs/call_apogee.png}
 \caption{Raycasting 2: Call Apogee as seen in  Episode 2, Floor 8} \label{fig:callapogeeingame}
\end{figure}

\begin{fancyquotes}
"Call Apogee and say Aardwolf."  It's a sign that to this day is something
that I get asked about a lot.  This is a sign that appears on a wall in a
particularly nasty maze in Episode 2 Level 8 of Wolfenstein 3D.  The sign
was to be the goal in a contest Apogee was going to have, but almost
immediately after the game's release, a large amount of cheat and mapping
programs were released.  With these programs running around, we felt that
it would have been unfair to have the contest and award a prize.  The sign
was still left in the game, but in hindsight, probably should have been
taken out.  To this day, Apogee gets letters and phone calls and asking
what Aardwolf is, frequently with the question, "Has anyone seen this yet?"\\
\\
Also, in a somewhat related issue, letters were shown after the highest score
in the score table in some revisions of the game.  These letters were to be
part of another contest that got scrapped before it got started, where we were
going to have people call in with their scores and tell us the code; we'd then
be able to verify their score.  However, with the cheat programs out there,
this got scrapped too.\\
\\
Basically, "Aardwolf" and the letters mean nothing now.  Also note that if
you found the Aardwolf sign in the game (without cheating), there's a VERY
strong chance that you're stuck in there.  The only way out may be to restart,
or load a saved game from before you went into that maze.\\
\\
\textbf{Joe Siegler - Past Pioneers of the Shareware Revolution}
\end{fancyquotes}













\subsection{Fixed point}
If integers were not accurate enough and floating points were too slow, how could trigonometry be done on those machines? The solution was to re-purpose the hardware via Fixed Points!\\
Fixed Point is a method that allows to keep track of fractions while still using the integer operations of the CPU. The machine manipulates what are supposed to be integer numbers but the programmers sees them as a real numbers. As usual it is easier to describe with a drawing. Integer are encoded following figure \ref{fig:int_layout}:
\begin{figure}[H]
\centering
 \input{int.tex}
 \caption{Integer layout.} \label{fig:int_layout}
 \end{figure}

So the value of the sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
\centering
\input{int_example.tex}
 \caption{Integer example.} \label{fig:mips}
 \end{figure}

 Is equal to $ 2^{13} + 2^9 + 2^5 + 2^1 =  8738 $.

\bigskip


Fixed Point arithmetic works by simply shifting the layout 8 bits to the left:
\begin{figure}[H]
 \centering
  \input{fp.tex}
 \caption{Fixed point layout.} \label{fig:mips}
\end{figure}

So the same sequence of bits \emph{0010010010010010}:
\begin{figure}[H]
 \centering
   \input{fp_example.tex}
  \caption{Fixed point example.} \label{fig:mips}
\end{figure} 

Now represents:\\
\\
$ 2^5 + 2^1 = 34 $ for the integer part.\\
$ 2^{-3}+2^{-7} = 0.1328125 $ for the fractional part.\\
$ = 34.1328125$\\

\bigskip

The beauty of this method is that addition and subtraction work exactly like integers from the CPU instruction side:
  \bigskip
  DRAWING
  \bigskip


 The only special case is when performing operation.

\bigskip
  DRAWING
  \bigskip



 \textbf{\underline{Trivia :}}  Fixed Point Arithmetic usage was not limited to PC gaming. Many game console manufactured in the 90s and later had no hardware floating point unit: Sony's original PlayStation (1994) and Sega's Saturn (1994) are few examples among many with a design choice that not only reduced the production cost but also maximized the CPU pipeline throughput.
 
 
 
 
 
 
 
 
 
 
 
 
 
\subsection{Raytracing: DDA Algorithm}
Digital Differential Analysis\\
Some ray are not traced ? How does that work ?\\
Precalculated sin-cos.\\
\subsection{FishEye}
The function in charge of calculating the heigh of a wall is CalcHeight:\\

\lstinputlisting[language=C]{code/CalcHeight.c}

The code is not what one would expect: The raytracing algorithm is supposed to cast a ray for each pixel column and use the distance \codeword{d} to infer an other value. So I would have expected to see something like:
\begin{math}
	d = \sqrt{dx^2 + dy^2}
\end{math}

but instead it looks like:
\begin{math}
	d = dx * \cos(\alpha) - dy * \sin(\alpha)
\end{math}.
Something is not right. Or misunderstood here.
\begin{figure}[H]
\centering
 \input{imgs/fish_eye/state.tex}
 \caption{Raycasting using distance d} \label{fig:Raycasting2}
\end{figure}

In this drawing the player is located at viewpoint with a view angle \begin{math}\alpha\end{math}. The distance \codeword{d} is a straight line between the player point of view and the location where the ray hit the line. Such an algorithm would result in a "fisheye effect". It is not very noticeable when a wall is far:

\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/fish_eye/bad_mild.png}
 \caption{Fish eye effect: Mild}. \label{fig:mips}
 \end{figure}

But it gets worse when you get closer:
\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/fish_eye/bad_ok.png}
 \caption{Fish eye effect: Bad} \label{fig:mips}
 \end{figure}

And become unbearable when close:
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/fish_eye/bad_bad.png}
 \caption{Fish eye effect: AAAAARG} \label{fig:mips}
 \end{figure}
 
To avoid this visual annoyance, what must be used is not the direct distance d but d projected on the perpendicular of the view direction:

\begin{figure}[H]
\centering
 \input{imgs/fish_eye/d_vs_z.tex}
 \caption{blabla.} \label{fig:Raycasting2}
\end{figure}

This projection is mathematically hard to calculate in one go (especially with fixed point). The trick is to break it down in two components and use highschool mnemonic: SOH-CAH-TOA\\

\begin{figure}[H]
\centering
 \input{imgs/fish_eye/correct_way.tex}
 \caption{blabla.} \label{fig:Raycasting2}
\end{figure}


 

 







 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/fish_eye/fish_eye.png}
 \caption{3D Rendere Phase 1: Background} \label{fig:mips}
 \end{figure}
 
 
  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/fish_eye/fish_eye_corrected.png}
 \caption{Fish eye: Uncorrected} \label{fig:mips}
 \end{figure}
 
  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/fish_eye/fish_eyed_start_screen2.png}
 \caption{Fish eye: Corrected} \label{fig:mips}
 \end{figure}
 Note: Why substract values insted of adding them ? The Wolf3D coordinate system has its origin at the upper left. This inverse the sin value. To compensate for it, the correction math uses substraction instead of addition.

\subsection{Ray skipping trick}
A naive implementation of the raycaster would be:\\
\lstinputlisting[language=C]{code/naive_raycaster_pseudocode.c}
But Wolf3D is different: It buffers what to draw:
\lstinputlisting[language=C]{code/wolf3d_raycaster_pseudocode.c}

Rendition is deferred because the engine allows itself to cheat a little: If a ray is cast and hits the same block and in the same
texture column, the two rays are considered similar. If two rays are similar they are drawn at the same height. The visual result is 
barely noticable. But this cheat allows to draw up to eight column of pixel in three write operations (in practice it is more like two columns
with one write operation). The details of this are in the method \codeword{ScalePost} in \codeword{WL\_DRAW.C}.\\

Note: A \quotes{post} is a column of pixel belonging to a wall.\\
ScalePost is written in assembly and performs a maximum of three pass to draw a maximum of eight columns of pixels.
\lstinputlisting[language=C]{code/ScalePost.c}
Because there can be many combinations of VGA bank alignment and number of pixels to draw:

\begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/scalePost_explanation1.png}
 \end{figure}
 
 \begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/scalePost_explanation2.png}
 \end{figure}
The instruction \codeword{or al , al} can be surprising. It means test if al is equal to zero and set the flag. Back in the day it was more populate than \codeword{test al, al}
 the VGA bank masks are harcoded in an array: One for each pass:\\
\lstinputlisting[language=C]{code/hardcoded_masks.c}
TODO: Were images stored rotated 90degres to increase cache hit ? No way, this was aimed at 386. BUT that would make the drawing easier !!

In the following example, the left wall is magnified. several rays hit the wall at the same texture location.
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/post_optimization_1_pink_show.png}
\end{figure}
The engine takes advantage of it and draw several columns (posts) efficiently with the VGA. The engine was altered to show the optimized posts in pink.
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/post_optimization_1_show.png}
\end{figure}

In the previous scene, 20\% of the wall was optimized away. In the next two screenshot, the same process, this time with the `eagle' texture:
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/post_optimization_2_show.png}
\end{figure}


\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/post_optimization_2_pink_show.png}
\end{figure}
 
To draw several column of pixels at the same time, the engine exploit the VGA banks and the masking mechanism seen in the Hardware section.
Since up to eight column can be similar, there are many case of figure depending on the aligment with the VGA banks and how many pixels to draw:

Example
 
\subsection{Door}
Doors have no tickness.\\
\begin{figure}[H]
 \centering
 \includegraphics[width=\textwidth]{imgs/door_flat.png}
\end{figure}
\subsection{Texturing}


Pre-Lighted texture.\\
Scaler (precompiled).\\
  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/baked_lights.png}
 \caption{3D Rendere Phase 1: Backed lights} \label{fig:backee_lights}
 \end{figure}

\subsection{Rendering phases}

Upon finishing parameter selection, the engine would switch from Menu phase to Action Phase which was mostly about rendering the 3D environment. The renderer operated in four phases:
\begin{itemize}
   \item Draw Background
   \item Draw Walls
   \item Draw scaled (entities such as enemies and items)
   \item Draw current weapon
\end{itemize}


Trivia: Hard-coded cos and sin lookup table. Budget ? 

\subsection{Square World and RayCasting}
TODO: Wolfenstein 3D referencial (64 grid, with origin and rotation
\subsection{Compiled Scalars}
Builds a compiled scaler object that will scale a 64 tall object to the given height (centered vertically on the screen).
\codeword{SetupScaling}\\
\codeword{BuildCompScale}
\lstinputlisting[language=C]{code/compscale.c}

  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/wall_texturw.png}
 \caption{3D Rendere Phase 1: Backed lights} \label{fig:backee_lights}
 \end{figure}

  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/light_sprite.png}
 \caption{3D Rendere Phase 1: Backed lights} \label{fig:backee_lights}
 \end{figure}
Trivia: This type of sprite would later turn out a major issue with hardware accelerated renderer for the iOS port:

\begin{fancyquotes}
Wolfenstein (and Doom) originally drew the characters as sparse stretched columns of solid pixels (vertical instead of horizontal for efficiency in interleaved planar mode-X VGA), but OpenGL versions need to generate a square texture with transparent pixels.  Typically this is then drawn by either alpha blending or alpha testing a big quad that is mostly empty space.  You could play through several early levels of Wolf without this being a problem, but in later levels there are often large fields of dozens of items that stack up to enough overdraw to max out the GPU and drop the framerate to 20 fps.  The solution is to bound the solid pixels in the texture and only draw that restricted area, which solves the problem with most items, but Wolf has a few different heavily used ceiling lamp textures that have a small lamp at the top and a thin but full width shadow at the bottom.  A single bounds doesn't exclude many texels, so I wound up including two bounds, which made them render many times faster. 
\bigskip \\
\textbf{John Carmack - Programmer}
 \end{fancyquotes}

  \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/guard_sprite.png}
 \caption{3D Rendere Phase 1: Backed lights} \label{fig:backee_lights}
 \end{figure}



\subsection{Rendering things}
\subsection{Loading screen}
 \begin{figure}[H]
\centering
 \includegraphics[width=\textwidth]{imgs/get_psyched.png}

 \end{figure}
 
One interesting aspect: Wall sprites were stored uncompressed but things are compressed in memory and decompressed while drawing occurs via bytecode.
